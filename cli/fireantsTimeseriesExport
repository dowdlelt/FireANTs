#!/usr/bin/env python3
# Copyright (c) 2025 Rohit Jena. All rights reserved.
#
# This file is part of FireANTs, distributed under the terms of
# the FireANTs License version 1.0. A copy of the license can be found
# in the LICENSE file at the root of this repository.

"""
Export timeseries registration results to standard formats.

Converts NPZ transform bundles to individual warp files and creates warped timeseries.
"""

import argparse
import sys
import logging
from pathlib import Path
import torch
import numpy as np
import SimpleITK as sitk

from fireants.io.timeseries import load_4d_nifti, load_frame_directory, load_transform_bundle
from fireants.io.image import Image
from fireants.interpolator import fireants_interpolator

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)


def parse_args():
    parser = argparse.ArgumentParser(
        description='Export timeseries registration results to individual warp files and warped volumes',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog='''
Examples:
  # Export from timeseries registration output
  fireantsTimeseriesExport \\
    --timeseries original.nii.gz \\
    --transforms output/timeseries_SyN_all.npz \\
    --output-dir output/warps/ \\
    --export-warped output/warped_timeseries.nii.gz

  # Only export individual warp files
  fireantsTimeseriesExport \\
    --timeseries original.nii.gz \\
    --transforms output/timeseries_SyN_all.npz \\
    --output-dir output/warps/
        '''
    )

    parser.add_argument('--timeseries', type=str, required=True,
                      help='Original timeseries file (4D NIfTI or directory)')
    parser.add_argument('--transforms', type=str, required=True,
                      help='Path to transform bundle (NPZ file from timeseries registration)')
    parser.add_argument('--output-dir', type=str, required=True,
                      help='Output directory for individual warp files')
    parser.add_argument('--export-warped', type=str, default=None,
                      help='Path to save warped timeseries (4D NIfTI). If not specified, skip warping.')
    parser.add_argument('--reference', type=str, default='first',
                      help='Reference frame: "first" (default), frame index, or external template path')
    parser.add_argument('--device', type=str, default='cuda:0',
                      help='Device for warping (default: cuda:0)')
    parser.add_argument('--dtype', type=str, default='float32', choices=['float32', 'float16', 'bfloat16'],
                      help='Data type for computation (default: float32)')

    return parser.parse_args()


def save_warp_as_nifti(warp_field: np.ndarray, reference_image: Image, output_path: str):
    """Save warp field as 4D NIfTI file (3 displacement components).

    Args:
        warp_field: Displacement field [z, y, x, 3] in voxel coordinates
        reference_image: Reference Image for spacing/direction/origin
        output_path: Output file path
    """
    # Upsample warp to full resolution if needed
    ref_shape = reference_image.itk_image.GetSize()  # [x, y, z] in SimpleITK
    ref_shape_zyx = (ref_shape[2], ref_shape[1], ref_shape[0])  # [z, y, x]

    if warp_field.shape[:3] != ref_shape_zyx:
        logger.info(f"Upsampling warp from {warp_field.shape[:3]} to {ref_shape_zyx}")
        # Warp is [z, y, x, 3] where 3 = [dx, dy, dz]
        # Permute to [3, z, y, x] for interpolation
        warp_torch = torch.from_numpy(warp_field).permute(3, 0, 1, 2).unsqueeze(0)  # [1, 3, z, y, x]
        warp_upsampled = torch.nn.functional.interpolate(
            warp_torch, size=ref_shape_zyx, mode='trilinear', align_corners=True
        )
        # Scale displacements proportionally
        # Components are [dx, dy, dz] so scale by [x_scale, y_scale, z_scale]
        scale_x = ref_shape_zyx[2] / warp_field.shape[2]  # x dimension
        scale_y = ref_shape_zyx[1] / warp_field.shape[1]  # y dimension
        scale_z = ref_shape_zyx[0] / warp_field.shape[0]  # z dimension
        warp_upsampled[0, 0] *= scale_x  # dx
        warp_upsampled[0, 1] *= scale_y  # dy
        warp_upsampled[0, 2] *= scale_z  # dz
        # Convert back to [z, y, x, 3]
        warp_field = warp_upsampled[0].permute(1, 2, 3, 0).numpy()

    # For isVector=True, SimpleITK expects the vector dimension to be LAST
    # Warp field is already [z, y, x, 3], which is the correct format
    # No transpose needed!

    # Create vector image
    itk_warp = sitk.GetImageFromArray(warp_field, isVector=True)

    # Copy metadata from reference
    itk_warp.SetSpacing(reference_image.itk_image.GetSpacing())
    itk_warp.SetOrigin(reference_image.itk_image.GetOrigin())
    itk_warp.SetDirection(reference_image.itk_image.GetDirection())

    # Save
    sitk.WriteImage(itk_warp, str(output_path))
    logger.debug(f"Saved warp: {output_path}")


def apply_warp_to_image(moving_image: Image, warp_field: torch.Tensor,
                        reference_image: Image, device: str) -> torch.Tensor:
    """Apply warp field to moving image.

    Args:
        moving_image: Image to warp
        warp_field: Displacement field [1, H, W, D, 3] as torch tensor
        reference_image: Reference Image for output space
        device: Device to run on

    Returns:
        Warped image tensor [1, C, H, W, D]
    """
    moving_array = moving_image.array.to(device)  # [1, C, H, W, D]
    warp_field = warp_field.to(device)

    # Apply warp using fireants interpolator
    warped = fireants_interpolator(
        moving_array,
        affine=None,
        grid=warp_field.contiguous(),
        mode='bilinear',
        align_corners=True,
        is_displacement=True
    )

    return warped


def export_individual_warps(frames, transforms, reference_image, output_dir):
    """Export individual warp files for each timepoint.

    Args:
        frames: List of Image objects
        transforms: List of warp field arrays [H, W, D, 3]
        reference_image: Reference Image for metadata
        output_dir: Output directory path
    """
    output_dir = Path(output_dir)
    output_dir.mkdir(parents=True, exist_ok=True)

    logger.info(f"Exporting {len(transforms)} individual warp files to {output_dir}/")

    for i, warp_array in enumerate(transforms):
        output_path = output_dir / f"warp_{i:04d}.nii.gz"
        save_warp_as_nifti(warp_array, reference_image, output_path)

        if (i + 1) % 50 == 0:
            logger.info(f"  Exported {i + 1}/{len(transforms)} warps...")

    logger.info(f"Successfully exported all {len(transforms)} warp files")


def create_warped_timeseries(frames, transforms, reference_image, output_path, device, dtype):
    """Create warped 4D timeseries volume.

    Args:
        frames: List of Image objects
        transforms: List of warp field arrays [z, y, x, 3]
        reference_image: Reference Image
        output_path: Output file path for 4D NIfTI
        device: Device to run on
        dtype: torch dtype
    """
    logger.info(f"Creating warped timeseries: {output_path}")
    logger.info(f"  Warping {len(frames)} timepoints...")

    # Get reference shape
    ref_shape = reference_image.itk_image.GetSize()  # [x, y, z]
    ref_shape_zyx = (ref_shape[2], ref_shape[1], ref_shape[0])  # [z, y, x]

    warped_volumes = []

    for i, (frame, warp_array) in enumerate(zip(frames, transforms)):
        # Upsample warp to full resolution if needed
        if warp_array.shape[:3] != ref_shape_zyx:
            if i == 0:
                logger.info(f"  Upsampling warps from {warp_array.shape[:3]} to {ref_shape_zyx}")
            # Warp is [z, y, x, 3] where 3 = [dx, dy, dz]
            # Permute to [3, z, y, x] for interpolation
            warp_torch = torch.from_numpy(warp_array).permute(3, 0, 1, 2).unsqueeze(0).to(dtype)  # [1, 3, z, y, x]
            warp_upsampled = torch.nn.functional.interpolate(
                warp_torch, size=ref_shape_zyx, mode='trilinear', align_corners=True
            )
            # Scale displacements proportionally
            # Components are [dx, dy, dz] so scale by [x_scale, y_scale, z_scale]
            scale_x = ref_shape_zyx[2] / warp_array.shape[2]  # x dimension
            scale_y = ref_shape_zyx[1] / warp_array.shape[1]  # y dimension
            scale_z = ref_shape_zyx[0] / warp_array.shape[0]  # z dimension
            warp_upsampled[0, 0] *= scale_x  # dx
            warp_upsampled[0, 1] *= scale_y  # dy
            warp_upsampled[0, 2] *= scale_z  # dz
            # Convert to [1, z, y, x, 3] for fireants_interpolator
            warp_tensor = warp_upsampled.permute(0, 2, 3, 4, 1)  # [1, 3, z, y, x] -> [1, z, y, x, 3]
        else:
            # Convert warp to torch tensor [1, z, y, x, 3]
            warp_tensor = torch.from_numpy(warp_array).unsqueeze(0).to(dtype)

        # Apply warp
        warped = apply_warp_to_image(frame, warp_tensor, reference_image, device)

        # Move to CPU and extract volume [z, y, x]
        warped_vol = warped[0, 0].cpu().numpy()  # Remove batch and channel dims

        if i == 0:
            logger.info(f"  Debug: warped tensor shape: {warped.shape}")
            logger.info(f"  Debug: warped_vol shape: {warped_vol.shape}")
            logger.info(f"  Debug: reference shape (x,y,z): {reference_image.itk_image.GetSize()}")

        warped_volumes.append(warped_vol)

        if (i + 1) % 50 == 0:
            logger.info(f"    Warped {i + 1}/{len(frames)} timepoints...")

    # Create list of 3D SimpleITK images for JoinSeries
    # Each volume is [z, y, x] from FireANTs
    logger.info(f"  Converting {len(warped_volumes)} volumes to SimpleITK format...")

    ref_itk = reference_image.itk_image
    itk_3d_list = []

    for vol in warped_volumes:
        # Convert to SimpleITK 3D image
        itk_3d = sitk.GetImageFromArray(vol)
        # Copy metadata from reference
        itk_3d.SetSpacing(ref_itk.GetSpacing())
        itk_3d.SetOrigin(ref_itk.GetOrigin())
        itk_3d.SetDirection(ref_itk.GetDirection())
        itk_3d_list.append(itk_3d)

    # Join series to create true 4D image
    logger.info(f"  Joining series to create 4D image...")
    itk_4d = sitk.JoinSeries(itk_3d_list)
    logger.info(f"  Debug: ITK 4D image size: {itk_4d.GetSize()}")
    logger.info(f"  Debug: ITK 4D image dimensions: {itk_4d.GetDimension()}")

    # JoinSeries automatically handles spatial metadata from the input 3D images
    # Just set the time spacing if desired (default is 1.0)
    # Note: SimpleITK's JoinSeries already sets spacing, origin, and direction correctly

    # Save
    sitk.WriteImage(itk_4d, str(output_path))
    logger.info(f"Successfully saved warped timeseries to {output_path}")


def load_reference(reference_str: str, frames, dtype, device):
    """Load reference image."""
    if reference_str == 'first':
        return frames[0]
    elif reference_str.isdigit():
        frame_idx = int(reference_str)
        return frames[frame_idx]
    else:
        return Image.load_file(reference_str, dtype=dtype, device=device)


def main():
    args = parse_args()

    # Parse dtype
    dtype_map = {
        'float32': torch.float32,
        'float16': torch.float16,
        'bfloat16': torch.bfloat16
    }
    dtype = dtype_map[args.dtype]

    # Load timeseries
    logger.info(f"Loading timeseries: {args.timeseries}")
    timeseries_path = Path(args.timeseries)
    if timeseries_path.is_dir():
        frames = load_frame_directory(args.timeseries, dtype=dtype, device=args.device)
    else:
        frames = load_4d_nifti(args.timeseries, dtype=dtype, device=args.device)
    logger.info(f"  Loaded {len(frames)} frames")

    # Load reference
    reference_image = load_reference(args.reference, frames, dtype, args.device)
    logger.info(f"  Reference: {args.reference}")

    # Load transforms
    logger.info(f"Loading transforms: {args.transforms}")
    transforms = load_transform_bundle(args.transforms, format='npz')
    logger.info(f"  Loaded {len(transforms)} transforms")

    # Validate
    if len(transforms) != len(frames):
        logger.warning(f"Transform count ({len(transforms)}) != frame count ({len(frames)})")
        logger.warning(f"Will process {min(len(transforms), len(frames))} timepoints")
        n_process = min(len(transforms), len(frames))
        transforms = transforms[:n_process]
        frames = frames[:n_process]

    # Export individual warp files
    export_individual_warps(frames, transforms, reference_image, args.output_dir)

    # Create warped timeseries if requested
    if args.export_warped:
        create_warped_timeseries(
            frames, transforms, reference_image,
            args.export_warped, args.device, dtype
        )

    logger.info("\nExport complete!")
    logger.info(f"  Individual warps: {args.output_dir}/")
    if args.export_warped:
        logger.info(f"  Warped timeseries: {args.export_warped}")


if __name__ == '__main__':
    try:
        main()
    except Exception as e:
        logger.error(f"Error: {e}", exc_info=True)
        sys.exit(1)
